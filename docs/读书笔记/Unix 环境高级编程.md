# Unix 基础知识

## 程序和进程

### fork

fork 后，子进程究竟是重新走 main 函数，还是从 fork 处开始往下走？

经过代码验证，是从 fork 处开始往下走：

```c
#include <stdio.h>

int main() {
    printf("main\n");
    int pid = fork();
    printf("%d\n", pid);
}
```

输出：

```shell
➜  Desktop ./a.out
main
20822
0
```

## 出错处理

Unix 中的出错处理分为两部分，一个是函数的返回，一个是 `errno` 。

* 函数一般返回 `-1` 或者 `null` 表示函数出错
* 但是具体的出错原因表示在 `errno`  中

### errno

每个线程都有属于自己的局部 errno。每个函数出错后，这个变量会被赋予一个值，这个就是出错的具体原因。

errno 有两个规则

1. 如果没有出错，他的值不会被清除。所以只有当函数的返回值指明错误的时候，才应该检查他的值
2. 任何函数都不会将 errno 的值设置为 0

接下来附一示例代码，帮助理解：

```c
#include <stdio.h>
#include <errno.h>
#include <fcntl.h>//在centos6.0中只要此头文件就可以
#include <sys/types.h>
#include <sys/stat.h>

int main()
{
    int f = open("test", O_WRONLY);
    printf("%d %d", f, errno);
}
```

 这段程序的输出就是 `-1 2` 。因为这个文件根本就不存在。

# 文件 I/O

## 内核用于所有的 I/O 的数据结构

内核使用 3 种数据结构表示打开文件。它们之间的关系决定了文件共享方面一个进程对另一个进程可能产生的影响。

1. 每个进程在进程表中都有一个记录项，记录项中包含一张打开文件描述符表。与每个文件描述符相关联的是：
   1. 文件描述符标志
   2. 指向一个文件表项的指针
2. 内核为所有打开文件维持一张文件表。每个文件表项包含：
   1. 文件状态标志（读，写，添写，同步和阻塞等）
   2. 当前文件偏移量
   3. 指向该文件 v 节点表项的指针
3. 每个打开文件都有一个 v 节点结构。v 节点包含了文件类型和对此文件进行操作函数的指针。对于大多数文件，v 节点还包含了该文件的 i 节点（索引节点）。这些信息是在打开文件时从磁盘上读入内存的，所以文件的所有相关信息都是随时可用的。例如：i 节点包含了文件的所有者、文件长度、指向文件实际数据块在磁盘上所在位置的指针等。

![](https://raw.githubusercontent.com/T-Oner/Notes/master/.gitbook/assets/unix_file_stuct.jpg)

## 函数 open 和 openat

```c
#include <fcntl.h>

int open(const char *path, int oflag, ... /* mode_t mode */);

int openat(int fd, const char *path, int oflag, ... /* mode_t mode */);
```

两者的函数签名的区别就是 `openat` 多了一个 `fd` ，这个 `fd` 参数是用来实现 `相对路径` 的功能

二者的区别：

1. `openat` 可以实现通过相对路径来打开文件
2. 可以避免 `TOCCTTOU` 错误

> 注：TOCCTTOU 错误的基本思想是，如果有两个基于文件的函数调用，其中第二个调用依赖于第一个调用的结果，那么程序是脆弱的。因为两个调用并不是源自操作，在两个函数调用之间文件可能改变了，这样就造成了第一个调用的接口就不再有效。

## 原子操作

> 在学习 I/O 的过程中，对原子操作又有了进一步的理解。

曾经以为原子操作这个东西很神奇。现在看来，只要在原子操作内，内核不要切换进程，一次执行完毕，就是原子操作。

但是**事务**这个概念还是有点模糊，如果事务失败了，怎么回退？回退的时候失败了怎么办？

# 文件和目录

## 新文件和目录的所有权

## 用户 ID

新文件的用户 ID 设置为进程的有效用户 ID。

## 组 ID

* 新文件的组 ID 可以是进程的有效组 ID
* 新文件的组 ID 可以是它所在目录的组 ID

## chmod、fchmod 和 fchmodat

* chmod

  在指定的文件上进行操作

* fchmod

  对已经打开的文件进行操作

* fchmodat

  * 和 chmod 在以下两种情况下是相同的
    * pathname 参数为绝对路径
    * fd 参数取 AT_FDCWD，而 pathname 参数为相对路径
  * 否则 fchmodat 计算相对于打开目录（由 fd 参数指向）的 pathname

## 文件长度

文件长度是指：stat 解构成员 st_size 表示以字节为单位的文件的长度。此字段只对普通文件、目录文件和符号链接有意义。

* 普通文件

  文件长度可以为 0

* 目录文件

  文件长度通常是一个数（ 16 或 512）的整倍数

* 符号链接

  文件长度是在文件名中的实际字节数

# 标准 I/O 库

## 缓冲

### 目的

标准 I/O 库提供缓冲的**目的**是：尽可能减少使用 read 和 write 调用的次数。

### 类型

* 全缓冲
* 行缓冲
* 不带缓冲

## 规范

* 标准错误不缓冲
* 打开至终端设备的流是行缓冲
* 其他都是全缓冲

# 进程环境

这章涵盖以下内容：当程序执行时，main 函数是如何被调用的；命令行参数是如何传递给新程序的；典型的存储空间布局是什么样式；如何分配另外的存储空间；进程如何使用环境变量；进程的各种不同终止方式等。

## main 函数

main 函数的原型是：

```c
int main(int argc, char *argv[]);
```

`argc` 是命令行参数的数目，`argv` 是指向参数的各个指针所构成的数组。

当内核执行 C 程序的时候，在调用 main 函数前调用一个特殊的启动例程。可执行文件将此启动例程指定为程序的起始地址。启动例程从内核取得命令行参数和环境变量值，然后为按上述方式调用 main 函数做好安排。

## 进程终止

有 8 种方式使进程终止，其实 5 种为正常终止：

1. 从 main 函数返回；
2. 调用 exit；
3. 调用 _exit 或 _Exit；
4. 最后一个线程从其启动例程返回；
5. 从最后一个线程调用 pthread_exit

异常终止有 3 种方式

1. 调用 abort
2. 接到一个信号
3. 最后一个线程对取消请求作出响应

### 退出函数

### 终止处理程序

